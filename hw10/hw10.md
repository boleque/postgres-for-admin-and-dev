# Домашнее задание

## Репликация


### 1. На 1 ВМ создаем таблицы test для записи, test2 для запросов на чтение.
Создан инстанс ec2 aws - pg-replication-vm1
```
-- создаем таблицы, test - на запись, test2 - на чтение
postgres=# CREATE TABLE test as select generate_series(1, 100) as id, md5(random()::text) ::char(10) as fio;
SELECT 100
postgres=# CREATE TABLE test2 (id serial, fio varchar(10));
CREATE TABLE
```

### 2. Создаем публикацию таблицы test и подписываемся на публикацию таблицы test2 с ВМ №2.
```
-- выставим wal_level на уровень logical 
postgres=# ALTER SYSTEM SET wal_level = logical;
ALTER SYSTEM

-- рестарт, чтобы применить изменения 
ubuntu@ip-172-31-37-83:~$ sudo systemctl restart postgresql@15-main

-- убеждаемся что изменения применены 
postgres=# show wal_level;
 wal_level 
-----------
 logical 

-- создаем публикацию таблицы test
postgres=# CREATE PUBLICATION test_publication_vm1 FOR TABLE test;
CREATE PUBLICATION

-- подписываемся на публикацию таблицы test2 vm2
postgres=# CREATE SUBSCRIPTION test2_subscription_vm2 CONNECTION 'host=172.31.37.83 user=postgres dbname=postgres password=123' PUBLICATION test2_publication_vm2 WITH (copy_data = TRUE);
NOTICE:  created replication slot "test2_subscription_vm2" on publisher
CREATE SUBSCRIPTION

-- проверяем что данные в таблице test2 есть
postgres=# select * from test2;
 id  |    fio     
-----+------------
   1 | f5a90bd2c8
   2 | ec9e8d3c35
   3 | 9596093cca
   4 | 4bfc19a5ed
   5 | e337a2b8b0
   6 | cbf774a69a
   7 | 6998990f4f
   8 | 7114263d15
   9 | 2cde0937f6
  10 | 5d24b11cd6

-- статус подписки
postgres=# SELECT * FROM pg_stat_subscription\gx
-[ RECORD 1 ]---------+------------------------------
subid                 | 16417
subname               | test2_subscription_vm2
pid                   | 18838
relid                 | 
received_lsn          | 0/156C9A0
last_msg_send_time    | 2024-02-14 20:38:06.730956+00
last_msg_receipt_time | 2024-02-14 20:38:06.731177+00
latest_end_lsn        | 0/156C9A0
latest_end_time       | 2024-02-14 20:38:06.730956+00

```

### 3. На 2 ВМ создаем таблицы test2 для записи, test для запросов на чтение.
Создан инстанс ec2 aws - pg-replication-vm2
```
-- создаем таблицы, test - на чтение, test2 - на запись
postgres=# CREATE TABLE test2 as select generate_series(1, 100) as id, md5(random()::text)::char(10)  as fio; 
SELECT 100
postgres=# CREATE TABLE test (id serial, fio varchar(10));
CREATE TABLE   
```

### 4. Создаем публикацию таблицы test2 и подписываемся на публикацию таблицы test1 с ВМ №1.
```
-- выставим wal_level на уровень logical 
postgres=# ALTER SYSTEM SET wal_level = logical;
ALTER SYSTEM

-- рестарт, чтобы применить изменения 
ubuntu@ip-172-31-37-83:~$ sudo systemctl restart postgresql@15-main

-- убеждаемся что изменения применены 
postgres=# show wal_level;
 wal_level 
-----------
 logical 

-- создаем публикацию таблицы test2
postgres=# CREATE PUBLICATION test2_publication_vm2 FOR TABLE test2;
CREATE PUBLICATION

-- подписываемся на публикацию таблицы test2 vm1
postgres=# CREATE SUBSCRIPTION test_subscription_vm1 CONNECTION 'host=172.31.33.195 user=postgres dbname=postgres password=123' PUBLICATION test_publication_vm1 WITH (copy_data = TRUE);
NOTICE:  created replication slot "test_subscription_vm1" on publisher
CREATE SUBSCRIPTION

-- проверяем что данные в таблице test есть
postgres=# select * from test;
 id  |    fio     
-----+------------
   1 | f5a90bd2c8
   2 | ec9e8d3c35
   3 | 9596093cca
   4 | 4bfc19a5ed
   5 | e337a2b8b0
   6 | cbf774a69a
   7 | 6998990f4f
   8 | 7114263d15
   9 | 2cde0937f6
  10 | 5d24b11cd6

-- статус подписки
postgres=# SELECT * FROM pg_stat_subscription\gx
-[ RECORD 1 ]---------+------------------------------
subid                 | 16399
subname               | test_subscription_vm1
pid                   | 18537
relid                 | 
received_lsn          | 0/1576D58
last_msg_send_time    | 2024-02-14 20:38:19.225892+00
last_msg_receipt_time | 2024-02-14 20:38:19.225997+00
latest_end_lsn        | 0/1576D58
latest_end_time       | 2024-02-14 20:38:19.225892+00
```
### 5. 3 ВМ использовать как реплику для чтения и бэкапов (подписаться на таблицы из ВМ №1 и №2 ).
Создан инстанс ec2 aws - pg-replication-vm3
```
-- создаем таблицы
postgres=# CREATE TABLE test (id serial, fio varchar(10));
CREATE TABLE
postgres=# CREATE TABLE test2 (id serial, fio varchar(10));  
CREATE TABLE

-- подписываемся на публикации таблицы test2 vm1, test1 vm2

postgres=# CREATE SUBSCRIPTION test_subscription_vm1 CONNECTION 'host=172.31.37.83 user=postgres dbname=postgres password=123' PUBLICATION test2_publication_vm2 WITH (copy_data = TRUE);
NOTICE:  created replication slot "test_subscription_vm1" on publisher
CREATE SUBSCRIPTION

postgres=# CREATE SUBSCRIPTION test_subscription_vm2 CONNECTION 'host=172.31.33.195 user=postgres dbname=postgres password=123' PUBLICATION test_publication_vm1 WITH (copy_data = TRUE);
NOTICE:  created replication slot "test_subscription_vm2" on publisher
CREATE SUBSCRIPTION

-- убеждаемся что данные на месте
postgres=# select * from test;
 id  |    fio     
-----+------------
   1 | f5a90bd2c8
   2 | ec9e8d3c35
   3 | 9596093cca
   4 | 4bfc19a5ed
   5 | e337a2b8b0
   6 | cbf774a69a
   7 | 6998990f4f
   8 | 7114263d15
   9 | 2cde0937f6
  10 | 5d24b11cd6

postgres=# select * from test2;
 id  |    fio     
-----+------------
   1 | a2e3d71dba
   2 | 74af4b99c6
   3 | bf3aaed38b
   4 | a614791263
   5 | 8302cc25a0
   6 | f4fc8a309e
   7 | ca9d2f5e48
   8 | a85ce16ddc
   9 | 74fdf4f4dc
  10 | a5a5eb6c0f

-- статус подписки
postgres=# SELECT * FROM pg_stat_subscription\gx
-[ RECORD 1 ]---------+------------------------------
subid                 | 16398
subname               | test_subscription_vm1
pid                   | 18506
relid                 | 
received_lsn          | 0/156C9A0
last_msg_send_time    | 2024-02-14 20:39:06.799575+00
last_msg_receipt_time | 2024-02-14 20:39:06.799668+00
latest_end_lsn        | 0/156C9A0
latest_end_time       | 2024-02-14 20:39:06.799575+00
-[ RECORD 2 ]---------+------------------------------
subid                 | 16399
subname               | test_subscription_vm2
pid                   | 18508
relid                 | 
received_lsn          | 0/1576D58
last_msg_send_time    | 2024-02-14 20:39:19.293625+00
last_msg_receipt_time | 2024-02-14 20:39:19.293711+00
latest_end_lsn        | 0/1576D58
latest_end_time       | 2024-02-14 20:39:19.293625+00

```
### 6. Дополнительные подготовительные действия
Для обеспечения коммуникации между кластерами, был установлен пароль для vm1, vm2
Сервер PG на vm1, vm2 слушает все адреса listen_addresses='*'
Отдельно прописаны ip адреса для каждой машины (pg_hba.conf), к которой будет подключение в рамках подписки:
```
-- pg-replication-vm1
ubuntu@ip-172-31-33-195:~$ sudo nano /etc/postgresql/15/main/pg_hba.conf
# vm2
host    postgres        postgres        172.31.37.83/32         trust
# vm3
host    postgres        postgres        172.31.41.188/32        trust

-- pg-replication-vm2
ubuntu@ip-172-31-37-83:~$ sudo nano /etc/postgresql/15/main/pg_hba.conf
# vm3
host    postgres        postgres        172.31.41.188/32        trust
# vm1
host    postgres        postgres        172.31.33.195/32        trust
```













Создан инстанс ec2 aws
### 2. Создаем БД, схему и в ней таблицу.
```
postgres=# CREATE DATABASE otus;
CREATE DATABASE
otus=# CREATE SCHEMA backups;
CREATE SCHEMA
```
### 3. Заполним таблицы автосгенерированными 100 записями.
```
otus=# CREATE TABLE backups.employees_1 as select generate_series(1, 100) as id, md5(random()::text)::char(10) as fio;
SELECT 100
otus=# SELECT * FROM backups.employees_1;
SELECT 100
 id  |    fio     
-----+------------
   1 | 9396f1306c
   2 | e0b5f95640
   3 | dfad916bd6
   4 | 8f957dc9d7
   5 | b09a1894da
   6 | 0e357c8506
   7 | 30afa68925
   8 | 37b59c5c2f
   9 | 30b3d4bb38
  10 | 524bd2ece7
  ....
 100 | a908aaa8b4
(100 rows)

```

### 4. Под линукс пользователем Postgres создадим каталог для бэкапов
```
postgres@ip-172-31-44-4:/mnt/pg_backups$ pwd
/mnt/pg_backups
```
### 5. Сделаем логический бэкап используя утилиту COPY
```
otus=# \copy backups.employees_1 to '/mnt/my_backups/employees_copy_backup.sql'
COPY 100
```
### 6. Восстановим в 2 таблицу данные из бэкапа.
```
otus=# create table backups.employees_2 (id serial, fio varchar(10));
CREATE TABLE
otus=# \copy backups.employees_2 from '/mnt/my_backups/employees_copy_backup.sql'
COPY 100
otus=# SELECT * FROM backups.employees_2;
 id  |    fio     
-----+------------
   1 | 9396f1306c
   2 | e0b5f95640
   3 | dfad916bd6
   4 | 8f957dc9d7
   6 | 0e357c8506
   7 | 30afa68925
   8 | 37b59c5c2f
   9 | 30b3d4bb38
  10 | 524bd2ece7
  ....
 100 | a908aaa8b4
(100 rows)

```
### 7. Используя утилиту pg_dump создадим бэкап в кастомном сжатом формате двух таблиц

```
postgres@ip-172-31-44-4:/$ pg_dump --dbname=otus --schema=backups --table=backups.employees_* --format=c --file=/mnt/my_backups/employees_pgdump_backup.sql
postgres@ip-172-31-44-4:/mnt/my_backups$ pg_restore -l employees_pgdump_backup.sql
;
; Archive created at 2024-02-10 18:41:48 UTC
;     dbname: otus
;     TOC Entries: 12
;     Compression: -1
;     Dump Version: 1.14-0
;     Format: CUSTOM
;     Integer: 4 bytes
;     Offset: 8 bytes
;     Dumped from database version: 15.5 (Ubuntu 15.5-1.pgdg22.04+1)
;     Dumped by pg_dump version: 15.5 (Ubuntu 15.5-1.pgdg22.04+1)
;
;
; Selected TOC Entries:
;
219; 1259 16402 TABLE backups employees_1 postgres
221; 1259 16406 TABLE backups employees_2 postgres
220; 1259 16405 SEQUENCE backups employees_2_id_seq postgres
3343; 0 0 SEQUENCE OWNED BY backups employees_2_id_seq postgres
3191; 2604 16409 DEFAULT backups employees_2 id postgres
3334; 0 16402 TABLE DATA backups employees_1 postgres
3336; 0 16406 TABLE DATA backups employees_2 postgres
3344; 0 0 SEQUENCE SET backups employees_2_id_seq postgres

```

### 8. Используя утилиту pg_restore восстановим в новую БД только вторую таблицу!
```
postgres=# CREATE DATABASE otus_another;
CREATE DATABASE
postgres=# CREATE SCHEMA backups;
CREATE SCHEMA
```
```
postgres@ip-172-31-44-4:/mnt/my_backups$ pg_restore --dbname=otus_another --table=employees_2 employees_pgdump_backup.sql
```

```
postgres=# \c otus_another
You are now connected to database "otus_another" as user "postgres".

 id  |    fio     
-----+------------
   1 | 9396f1306c
   2 | e0b5f95640
   3 | dfad916bd6
   4 | 8f957dc9d7
   5 | b09a1894da
   6 | 0e357c8506
   7 | 30afa68925
   8 | 37b59c5c2f
   9 | 30b3d4bb38
  10 | 524bd2ece7
  ....
 100 | a908aaa8b4
(100 rows)
```

**Выводы:**
Опробовано 2 утилиты для логического бэкапа - copy и pg_dump.
Все данные были корректно восстановленны в таблицу employees_2